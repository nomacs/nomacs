<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>LibRaw: Usage Examples</title>
  </head>

  <body>
    <a href=index.html>[back to Index]</a>
    <h1>LibRaw: Usage Examples</h1>
    
    <h2>Overview of Examples in the Distribution Package (samples/*)</h2>
    <p>The LibRaw package contains several examples illustrating the use of this library.
Their source codes are located in the samples/ folder, and after library build they will be in the bin/ folder:</p>
    <ul>
      <li><b>raw-identify</b> The only LibRaw call it uses is <a href="API-CXX.html#open_file">open_file()</a>; 
        further code prints the values of the fields of the imgdata structure. The output of 
        <b>raw-identify</b>/<b>raw-identify -v</b> is virtually identical to the output of 
        <b>dcraw -i</b>/<b>dcraw -i -v </b> (in the output of this example, the sources of color data in the numeric
        form are additionally printed). Command line key <b>-u</b> shows unpacking function name, while <b>-u -f</b>
        prints function name and masked are sizes.
      </li>
      <li><b>simple_dcraw</b> A simple &quot;emulation&quot; of dcraw reproducing the behavior of  
        <b>dcraw [-D] [-e] [-v] [-T]</b>. The result of its work must be binary identical to the result produced by a
        dcraw run with relevant keys. A simplified version of this example is <a href="#code">considered below</a>.
        <br/>
        <b>-B</b> command-line switch turns on use of <a href="API-CXX.html#open_buffer">open_buffer() API call</a>
        used via mmap() of input file (Unix only).     
      </li>
      <li><b>dcraw_half</b> Demonstrates the use of <a href="API-C.html">C API</a>. The example emulates the 
        behavior of <b>dcraw -h</b> (no other control parameters can be specified in this example). The result of its
        work must be binary identical to the results produced by <b>dcraw -h</b>. 
      </li>
      <li><b>dcraw_emu</b> Complete emulation of dcraw (except for keys -D -d -P -K -i -e, which are considered in
        other usage examples). Of most interest is processing of command line keys (copied from dcraw).  The result of
        its work must be binary identical to the results produced by dcraw with the same command line keys. 

        <p>
          This sample supports additional command-line parameters absent in original dcraw:
        </p>
        <dl>
          <dt><b>-mmap</b></dt>
          <dd>
            Use <a href="API-CXX.html#open_buffer">open_buffer()</a> interface. Buffer prepared by mmap()
            call. This option not supported under Win32.
          </dd>
          <dt><b>-meme</b></dt>
          <dd>
            Use <a href="API-CXX.html#open_buffer">open_buffer()</a> interface. Buffer prepared by 
            malloc()+read() calls.
          </dd>
          <dt><b>-c float-value</b></dt>
          <dd>
            This key sets <strong>params.adjust_maximum_thr</strong> parameter.<br/>
            Use -c 0 to completely disable automatic maximum calculation.
            <br/>
            Default value: 0.75
          </dd>
          <dt><b>-timing</b></dt>
          <dd>
            Turns on detailed timing print.
          </dd>
          <dt><b>-G</b></dt>
          <dd>
            Turns on "green_matching" mode to suppress color mazes on cameras with different green channels.
          </dd>
          <dt><b>-B x y w h</b></dt>
          <dd>
            Crops output to rectangle with width w, height h and x,y coordinates of left upper corner.
            All coordinates applied before any image rotation.
          </dd>
          <dt><b>-dcbi N</b></dt>
          <dd>
            Sets number of additional DCB-demosaic iterations (option valid only for -q 4, i.e. for DCB demosaic).
          </dd>
          <dt><b>-dcbe</b></dt>
          <dd>
            Turns on DCB color enhance mode (only for DCB demosaic, -q 4).
          </dd>
          <dt><b>-eeci</b></dt>
          <dd>
            Turns on EECI refine (only for mixed VCD/AHD -q 8)
          </dd>
          <dt><b>-esmed N</b></dt>
          <dd>
            Number of passes of edge-sensitive median filter for VCD+AHD demosaic.
          </dd>
          <dt><b>-acae r b</b></dt>
          <dd>
            Turns on chromatic aberration suppression. r and b parameters are amount of red and blue axis correction
            respectively. For automatic correction use <b>-acae 0 0</b>.
          </dd>
          <dt><b>-aline l</b></dt>
          <dd>
            Turns on banding suppression. l is the correction amount, useable range is from 0.001 to 0.02, typical
            value is 0.005.
          </dd>
          <dt><b>-aclean l c</b></dt>
          <dd>
            Turns on impulse noise suppression. l and c are luminocity and chrominance suppression values,
            respectively. Useable range for both is 0.005-0.05 and typical value is 0.01.
          </dd>
          <dt><b>-agreen g</b></dt>
          <dd>
            Turns on green channels equalization on uniform surfaces. g is the algorithm sensitivity with
            useable range 0.01-0.1 and typical value 0.03.
          </dd>
          <dt><b>-aexpo e p</b></dt>
          <dd>
            Turns on exposure correction. e is exposure shift in linear scale from 0.25 (darken 2 stops) to
            8.0 (lighten 3 stops). p is highlights preservation amount from 0.0 (no preservation, full clipping)
            to 1.0 (full preservation, S-like curve in highlights).
          </dd>
        </dl>
      </li>
      <li><b>half_mt</b> Emulation of <b>dcraw -h</b>. It &quot;understands&quot; the following keys: -a (automatic
        white balance over the entire image), -w (white balance of the camera), -T (output in the tiff format), and -J
        n (number of parallel threads launched for image processing).<br/>
        On multiprocessor/multicore computers, the speed gain is notable in the case of mass processing. On a 
        Win32 machine, the example is assembled from the initial file half_mt_win32.c, since
        work with threads under Windows is fundamentally different and it it easier to copy simple source codes
        than write one complex code. 
      </li>
      <li><b>mem_image</b> This sample uses 
        <a  href="API-CXX.html#dcraw_make_mem_image">dcraw_make_mem_image</a> and
        <a  href="API-CXX.html#dcraw_make_mem_thumb">dcraw_make_mem_thumb</a> calls, than writes data in PPM
        format.  Results should be identical with dcraw with same command-line options (options supported: 
        <b>-4, -1, -e, -h</b>). 
      </li>
      <li><b>unprocessed_raw</b> This sample extracts (mostly) unaltered RAW data including masked pixels
        data (on supported cameras). 
        If black frame exists and black frame extraction is supported for given format, masked pixels
        data is added to resulting .TIFF file.
        Command line options: <b>-q</b> - be quiet, <b>-A</b> - autoscale data (integer multiplier),
        <b>-g</b> gamma-correction (gamma 2.2) for data (instead of precise linear one),  <b>-B</b> turns on black
        level subtraction 
        </li>
      <li><b>4channnels</b> - splits RAW-file into four separate 16-bit grayscale TIFFs (per RAW channel).<br/>
        Command line switches:
        <ul>
          <li><b>-s N</b> selects  N-th image from RAW with multiple images</li>
          <li><b>-g</b> gamma correction (gamma 2.2)</li>
          <li><b>-A</b> values autoscale by auto-calculated integer factor</li>
          <li><b>-B</b> turn off black subtraction</li>
          <li><b>-N</b> no RAW curve </li>
        </ul>
      </li>
      <li><b>multirender_test</b> - very simple example of multiple rendering on one file without reopen.
      </li>
    </ul>
    <h2>Example of docmode</h2>
    <p>Below we consider the samples/simple_dcraw.cpp example, which emulates the behavior of 
      <b>dcraw [-D] [-e][-v][-t]</b>. To save space, let us assume that keys -t -v are always specified (to avoid
      comments on command line parsing) and there is always one parameter (name of file), which is the only one and
      always passed to the program.  
    </p>
<pre>
int main(int ac, char *av[])
{
    int  i, ret, verbose=0, output_thumbs=0;
    char outfn[1024],thumbfn[1024]; 

    // Creation of image processing object
    LibRaw RawProcessor;
    
    // The date in TIFF is written in the local format; let us specify the timezone for compatibility with dcraw 
    putenv ((char*)"TZ=UTC"); 

// Let us define variables for convenient access to fields of RawProcessor

#define P1  RawProcessor.imgdata.idata
#define S   RawProcessor.imgdata.sizes
#define C   RawProcessor.imgdata.color
#define T   RawProcessor.imgdata.thumbnail
#define P2  RawProcessor.imgdata.other
#define OUT RawProcessor.imgdata.params

    OUT.output_tiff = 1; // Let us output TIFF

   // Let us open the file
   if( (ret = RawProcessor.open_file(av[1])) != LIBRAW_SUCCESS)
      {
          fprintf(stderr,"Cannot open %s: %s\n",av[i],libraw_strerror(ret));

          // recycle() is needed only if we want to free the resources right now. 
          // If we process files in a cycle, the next open_file() 
          // will also call recycle(). If a fatal error has happened, it means that recycle()
          // has already been called (repeated call will not cause any harm either).

          RawProcessor.recycle(); 
          goto end;
      }

   // Let us unpack the image
   if( (ret = RawProcessor.unpack() ) != LIBRAW_SUCCESS)
      {
          fprintf(stderr,"Cannot unpack_thumb %s: %s\n",av[i],libraw_strerror(ret));

          if(LIBRAW_FATAL_ERROR(ret))
                    goto end;
          // if there has been a non-fatal error, we will try to continue
      }
  // Let us unpack the thumbnail
  if( (ret = RawProcessor.unpack_thumb() ) != LIBRAW_SUCCESS)
     {
          // error processing is completely similar to the previous case
           fprintf(stderr,"Cannot unpack_thumb %s: %s\n",av[i],libraw_strerror(ret));
           if(LIBRAW_FATAL_ERROR(ret))
                   goto end; 
    }
  else // We have successfully unpacked the thumbnail, now let us write it to a file
    {
      snprintf(thumbfn,sizeof(thumbfn),"%s.%s",av[i],T.tformat == LIBRAW_THUMBNAIL_JPEG ? "thumb.jpg" : "thumb.ppm");
      if( LIBRAW_SUCCESS != (ret = RawProcessor.dcraw_thumb_writer(thumbfn)))
        {
                fprintf(stderr,"Cannot write %s: %s\n",thumbfn,libraw_strerror(ret));

                // in the case of fatal error, we should terminate processing of the current file
                if(LIBRAW_FATAL_ERROR(ret))
                          goto end; 
        }
    }
   // Data unpacking
   ret = RawProcessor.dcraw_process();

    if(LIBRAW_SUCCESS != ret ) // error at the previous step
          {
               fprintf(stderr,"Cannot do postprocessing on %s: %s\n",av[i],libraw_strerror(ret));
               if(LIBRAW_FATAL_ERROR(ret))
                        goto end;
          }
   else  // Successful document processing
     {
        snprintf(outfn,sizeof(outfn),"%s.%s", av[i], "tiff");
        if( LIBRAW_SUCCESS != (ret = RawProcessor.dcraw_ppm_tiff_writer(outfn)))
                fprintf(stderr,"Cannot write %s: error %d\n",outfn,ret);
     }

  // we don't evoke recycle() or call the desctructor; C++ will do everything for us
  return 0;
end:
  // got here after an error
  return 1;
}
</pre>


    <a href=index.html>[back to Index]</a>
  </body>
</html>
